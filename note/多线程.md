# 目录
* 1 [队列](#队列)
  * 1.1 [ConcurrentLinkedQueue](#ConcurrentLinkedQueue)
  * 1.2 [BlockingQueue](#BlockingQueue)

## 创建线程的方式
- 继承Thread类，实现run方法
- 实现Runnable接口，实现run方法
- 实现Callable接口，实现call方法
- 线程池
实现Runnable和实现Callable都可以用lambda简写


### Callable的使用
Callable可以在执行后拿到异步执行的结果。<br>
线程池使用Callable，如果不拿返回值也可以直接用execute方法
```java
ExecutorService service = Executors.newCachedThreadPool();
Future<String> result = service.submit(new MyCall());
System.out.println("future result:" + result.get());
```
单独线程使用Callable，需要FutureTask进行包装
```java
  FutureTask<String> task = new FutureTask<>(new MyCall());
  new Thread(task).start();
  System.out.println("FutureTask result:" + task.get());
```

### 线程数多少合适
大致估算的话可以用公式:
```
threadNumber = cpuNumber * cpuPercent * (1 + W/C)
```
cpuPercent 期望的cpu利用率<br>
W/C是等待时间与计算时间的比率<br><br>
这里推荐两个工具:<br>
profiler性能监测工具可以检测到cpu计算时间.<br>
arthas阿里云工具监测线上服务器<br>



## 队列
### ConcurrentLinkedQueue
一个线程安全的队列。<br/>
常用api
> * offer(E) 提交一个元素
> * peek() 窥视，获取一个元素，没有remove操作
> * poll() 取出，含remove操作
### BlockingQueue
线程安全并且阻塞的队列。<br/>
当take并且没有元素时会阻塞，直到有元素进来并取出元素。<br>
常用api
> * 包含ConcurrentLinkedQueue的api
> * put(E) 阻塞式提交
> * take() 阻塞式取出
### DelayQueue
延迟阻塞队列。放入的对象必须实现Delayed接口，自定义好排序规则，排序小的优先出来。其本质是PriorityQueue。<br>
实现Delayed接口
```java
    /**
     * 定义一个延迟对象
     * 并实现其时间方法
     */
    static class MyTask implements Delayed{
        String name;
        long runningTime;

        public MyTask(String name, long runningTime) {
            this.name = name;
            this.runningTime = runningTime;
        }

        @Override
        public long getDelay(TimeUnit unit) {
            return unit.convert(runningTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);
        }

        @Override
        public int compareTo(Delayed o) {
            if (this.getDelay(TimeUnit.MILLISECONDS) < o.getDelay(TimeUnit.MILLISECONDS)){
                return -1;
            }else if (this.getDelay(TimeUnit.MILLISECONDS) > o.getDelay(TimeUnit.MILLISECONDS)){
                return 1;
            }else{
                return 0;
            }
        }

        @Override
        public String toString() {
            return name + " " + runningTime;
        }
    }
```
### SynchronousQueue与LinkedTransferQueue
不是用来装元素的Queue，而是用来线程之间传递数据。<br>
当put或transfer时如果元素没有被取出，则会被阻塞住。
