# 目录
* 1 [队列](#队列)
  * 1.1 [ConcurrentLinkedQueue](#ConcurrentLinkedQueue)
  * 1.2 [BlockingQueue](#BlockingQueue)

## 创建线程的方式
- 继承Thread类，实现run方法
- 实现Runnable接口，实现run方法
- 实现Callable接口，实现call方法
- 线程池
实现Runnable和实现Callable都可以用lambda简写


### Callable的使用
Callable可以在执行后拿到一个异步执行的未来结果对象Future，通过Future的get方法可以阻塞式地得到执行结果。<br>
线程池使用Callable，如果不拿返回值也可以直接用execute方法
```java
ExecutorService service = Executors.newCachedThreadPool();
Future<String> result = service.submit(new MyCall());
System.out.println("future result:" + result.get());
```
单独线程使用Callable，需要FutureTask进行包装
```java
  FutureTask<String> task = new FutureTask<>(new MyCall());
  new Thread(task).start();
  System.out.println("FutureTask result:" + task.get());
```

### 线程数多少合适
大致估算的话可以用公式:
```
threadNumber = cpuNumber * cpuPercent * (1 + W/C)
```
cpuPercent 期望的cpu利用率<br>
W/C是等待时间与计算时间的比率<br><br>
这里推荐两个工具:<br>
profiler性能监测工具可以检测到cpu计算时间.<br>
arthas阿里云工具监测线上服务器<br>

### Executor
Executor: 执行器，用来执行任务(线程)。<br>
ExecutorService: 对执行器做了一层包装，完善了生命周期。并且提供了一些批量api
>* invokeAll批量任务提交，返回List<Future>
>* invokeAny批量任务提交，返回最先执行完的结果

其实现就是线程池ThreadPoolExecutor

## 线程池

### ThreadPoolExecutor
```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
        2,4, //核心2， 最大4
        60, TimeUnit.SECONDS, //空闲维持60秒销毁线程对象
        new ArrayBlockingQueue<>(4), // 队列长度4
        Executors.defaultThreadFactory(), //默认线程工厂
        new ThreadPoolExecutor.CallerRunsPolicy()); //拒绝策略
```
* corePoolSize：线程池维护线程的最少数量
* maximumPoolSize：线程池维护线程的最大数量,只有在缓冲队列满了之后才会申请超过核心线程数的线程
* keepAliveSeconds：存活时间,当超过了核心线程出之外的线程在空闲时间到达之后会被销毁
* TimeUnit：存活时间的单位
* BlockingQueue：缓存队列
* ThreadFactory：线程工厂，可以用默认的
* rejectedExecutionHandler：线程池对拒绝任务（无线程可用）的处理策略

#### 核心线程、最大线程、队列之间的关系：
先使用核心线程，<br>
核心线程满了之后再申请的线程放到队列，<br>
队列满了之后再申请的线程放到最大线程(扩容)，<br>
最大线程也满了开始拒绝策略，java自带了4种拒绝策略，根据实际情况可以自定义拒绝策略，比如多的申请放到中间件<br>
* Abort: 抛异常
* Discard: 扔掉新申请的，不抛异常
* DiscardOldest: 扔掉最老的，把新的塞进去
* CallerRuns: 由调用者(主线程)自己执行，不再异步

队列内容可以继续往下看

### java提供的常用线程池
```java
Executors.newSingleThreadExecutor();
Executors.newCachedThreadPool();
Executors.newFixedThreadPool(8);
Executors.newWorkStealingPool(); //实现是ForkJoinPool
```
## ForkJoinPool
分叉合并型线程池，和ThreadPoolExecutor是两种不同的类型。
api方法
> * execute(E) 执行任务
> * join() 获取执行结果

执行的任务类需要继承RecursiveTask<T> （写了T就有返回值，不写没有）,
实现其compute方法，并在里面做fork()的分叉执行，fork()会调用compute实现递归分叉。
代码示例:
```java
    static class AddTaskReturn extends RecursiveTask<Long> {
        int start, end;

        AddTaskReturn(int s, int e){
            start = s;
            end = e;
        }
        @Override
        protected Long compute() {
            if (end - start <= MAX_NUM){
                long sum = 0L;
                for (int i=start; i<end; i++){
                    sum += nums[i];
                }
                return sum;
            }else{
                //否则继续分片
                int middle = start + (end - start) / 2;

                AddTaskReturn subTask1 = new AddTaskReturn(start, middle);
                AddTaskReturn subTask2 = new AddTaskReturn(middle, end);
                subTask1.fork();
                subTask2.fork();
                return subTask1.join() + subTask2.join();
            }
        }
    }
```






## 常用高并发容器
* ConcurrentHashMap
* ConcurrentSkipListMap 高并发且排序，跳表结构
* CopyOnWriteArrayList 写时复制，新增时复制一个新的容量加1的数组，然后直接替换掉内存引用，带复制的操作有锁，读取没有锁。适用于读多写少的情况

## 队列
### ConcurrentLinkedQueue
一个线程安全的队列。<br/>
常用api
> * offer(E) 提交一个元素
> * peek() 窥视，获取一个元素，没有remove操作
> * poll() 取出，含remove操作
### BlockingQueue
线程安全并且阻塞的队列。<br/>
包含ArrayBlockingQueue、LinkedBlockingQueue、LinkedBlockingDeque、PriorityBlockingQueue<br/>
当take并且没有元素时会阻塞，直到有元素进来并取出元素。<br>
常用api
> * 包含ConcurrentLinkedQueue的api
> * put(E) 阻塞式提交，容器满了会阻塞
> * take() 阻塞式取出，没有元素时会阻塞
### DelayQueue
延迟阻塞队列。放入的对象必须实现Delayed接口，自定义好排序规则，排序小的优先出来。其本质是PriorityQueue。<br>
实现Delayed接口示例代码
```java
    /**
     * 定义一个延迟对象
     * 并实现其时间方法
     */
    static class MyTask implements Delayed{
        String name;
        long runningTime;

        public MyTask(String name, long runningTime) {
            this.name = name;
            this.runningTime = runningTime;
        }

        @Override
        public long getDelay(TimeUnit unit) {
            return unit.convert(runningTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);
        }

        @Override
        public int compareTo(Delayed o) {
            if (this.getDelay(TimeUnit.MILLISECONDS) < o.getDelay(TimeUnit.MILLISECONDS)){
                return -1;
            }else if (this.getDelay(TimeUnit.MILLISECONDS) > o.getDelay(TimeUnit.MILLISECONDS)){
                return 1;
            }else{
                return 0;
            }
        }

        @Override
        public String toString() {
            return name + " " + runningTime;
        }
    }
```
### SynchronousQueue与LinkedTransferQueue
不是用来装元素的Queue，而是用来线程之间传递数据。<br>
当put或transfer时如果元素没有被取出，则会被阻塞住。
